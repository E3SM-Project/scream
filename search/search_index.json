{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The C++ E3SM Atmosphere Model (EAMxx)","text":"<p>Some nice introductory text goes here! Maybe some figures, too. Who knows?</p> <ul> <li>The User Guide guide explains how to run EAMxx, both in   its standalone configuration and within E3SM.</li> <li>The Developer Guide guide contains all the information needed   to contribute to the development of EAMxx.</li> </ul>"},{"location":"common/installation/","title":"Installation","text":""},{"location":"common/installation/#prerequisites","title":"Prerequisites","text":""},{"location":"common/installation/#setting-up-your-environment","title":"Setting Up Your Environment","text":""},{"location":"common/installation/#configuring-and-building-scream","title":"Configuring and Building Scream","text":""},{"location":"common/installation/#running-tests","title":"Running Tests","text":""},{"location":"dev/","title":"SCREAM Developer Guide","text":""},{"location":"dev/field/","title":"Fields","text":""},{"location":"dev/field/#field","title":"Field","text":"<p>In EAMxx, a <code>Field</code> is a data structure holding two things: pointers to the data and pointers to metadata. Both the data and metadata are stored in <code>std::shared_ptr</code> instances, to ensure consistency across all copies of the field. This allows for fast shallow copy semantic for this class.</p> <p>The data is stored on both CPU and device memory (these may be the same, depending on the Kokkos backend). In EAMxx, we always assume and guarantee that the device data is up to date. That implies that the data be explicitly synced to host before using it on host, and explicitly synced to device after host manipulation, in order to ensure correctness. In order to access the data, users must use the <code>get_view</code> method, which takes two template arguments: the data type, and an enum specifying whether CPU or device data is needed. The data type is used to reinterpret the generic pointer stored inside to a view of the correct scalar type and layout. It is a possibly const-qualified type, and if the field was marked as \"read-only\", the method ensures that the provided data type is const. A read-only field can be created via the <code>getConst</code> method, which returns an identical copy of the field, but marked as read-only. The enum specifying host or device data is optional, with device being the default.</p> <p>The metadata is a collection of information on the field, such as name, layout, units, allocation size, and more. Part of the metadata is immutable after creation (e.g., name, units, or layout), while some metadata can be partially or completely modified. The metadata is contained in the <code>FieldHeader</code> data structure, which contains four parts:</p> <ul> <li><code>FieldIdentifier</code>: stores the field's name, layout, units, data type, and name of the grid where it's defined.   These information are condensed in a single string, that can be used to uniquely identify a field,   allowing to distinguish between different version of the same field. The layout is stored in the <code>FieldLayout</code>   data structure, which includes:<ul> <li>the field tags: stored as a <code>std::vector&lt;FieldTag&gt;</code>, they give context to the field's extents.</li> <li>the field dims: stored both as a <code>std::vector&lt;int&gt;</code>, as well as a 1d <code>Kokkos::View</code>.</li> </ul> </li> <li><code>FieldTracking</code>: stores information on the usage of the field, as well as its possible connections to other   fields. In particular, the tracked items are:<ul> <li>the field time stamp: the time stamp when the field was last updated.</li> <li>the field accumulation start time: used for fields that are accumulated over several time steps   (or time step subcycles). For instance, it allows to reconstruct fluxes from raw accumulations.</li> <li>the providers/customers: lists of atmosphere processes (see below) that respectively require/compute   the field in their calculations.</li> <li>the field groups: a list of field groups that this field belongs too. Field groups are used to access   a group of fields without explicit prior knowledge about the number and/or names of the fields.</li> </ul> </li> <li><code>FieldAllocProp</code>: stores information about the allocation. While the field is not yet allocated, users can   request special allocations for the field, for instance to accommodate packing (for SIMD), which may   require padding. Upon allocation, this information is then used by the Field structure to extract the   actual data, wrapped in a properly shaped <code>Kokkos::View</code>. The alloc props are also responsible of tracking   additional information in case the field is a \"slice\" of a higher-dimensional one, a fact that can affect   how the data is accessed.</li> <li>Extra data: stored as a <code>std::map&lt;std::string,ekat::any&gt;</code>, allows to catch any metadata that does not fit   in the above structures. This is a last resort structure, intended to accommodate the most peculiar   corner cases, and should be used sparingly.</li> </ul>"},{"location":"dev/grid/","title":"Grids and Remappers","text":""},{"location":"dev/grid/#grids-and-remappers","title":"Grids and Remappers","text":"<p>In EAMxx, the <code>AbstractGrid</code> is an interface used to access information regarding the horizontal and vertical discretization. The most important information that the grid stores is:</p> <ul> <li>the number of local/global DOFs: these are the degrees of freedom of the horizontal grid only. Here,   local/global refers to the MPI partitioning.</li> <li>the DOFs global IDs (GIDs): a list of GIDs of the DOFs on the current MPI rank, stored as a Field</li> <li>the local IDs (LIDs) to index list: this list maps the LID of a DOF (that is, the position of the DOF   in the GID list) to a \"native\" indexing system for that DOF. For instance, a <code>PointGrid</code> (a class derived from   <code>AbstractGrid</code>) is a simple collection of points, so the \"native\" indexing system coincides with the LIDs.   However, for a <code>SEGrid</code> (a derived class, for spectral element grids), the \"native\" indexing is a triplet   <code>(ielem,igp,jgp)</code>, specifying the element index, and the two indices of the Gauss point within the element.</li> <li>geometry data: stored as a <code>std::map&lt;std::string,Field&gt;</code>, this represent any data that is intrinsically   linked to the grid (either along the horizontal or vertical direction), such as lat/lon coordinates,   vertical coordinates, area associated with the DOF.</li> </ul> <p>Grids can also be used to retrieve the layout of a 2d/3d scalar/vector field, which allows certain downstream classes to perform certain operations without assuming anything on the horizontal grid.</p> <p>In general, grid objects are passed around the different parts of EAMxx as const objects (read-only). The internal data can only be modified during construction, which usually is handled by a <code>GridsManager</code> object.</p>"},{"location":"dev/io/","title":"Input-Output","text":"<p>In EAMxx, I/O is handled through the SCORPIO library, currently a submodule of E3SM. The <code>scream_io</code> library within eamxx allows to interface the EAMxx infrastructure classes with the SCORPIO library.</p>"},{"location":"dev/kokkos_ekat/","title":"Building Blocks","text":"<p>Here we can discuss EKAT, Kokkos, and all of the highly-technical non-scientific stuff that makes our heads hurt.</p>"},{"location":"dev/kokkos_ekat/#kokkos-views","title":"Kokkos Views","text":""},{"location":"dev/kokkos_ekat/#vectorization-packs","title":"Vectorization: Packs","text":""},{"location":"dev/kokkos_ekat/#fields-and-the-field-manager","title":"Fields and the Field Manager","text":""},{"location":"dev/kokkos_ekat/#preconditions-postconditions-and-invariants","title":"Preconditions, Postconditions, and Invariants","text":""},{"location":"dev/managers/","title":"Managers","text":""},{"location":"dev/managers/#fieldmanager-and-gridsmanager","title":"FieldManager and GridsManager","text":""},{"location":"dev/processes/","title":"Atmospheric Processes","text":""},{"location":"dev/processes/#the-atmosphereprocess-class","title":"The AtmosphereProcess Class","text":""},{"location":"dev/processes/#microphysics-p3","title":"Microphysics (P3)","text":""},{"location":"dev/processes/#macrophysicsturbulence-shoc","title":"Macrophysics/Turbulence (SHOC)","text":""},{"location":"dev/processes/#radiation-rrtmgp","title":"Radiation (RRTMGP)","text":""},{"location":"dev/processes/#aerosols-spa","title":"Aerosols (SPA)","text":""},{"location":"dev/style_guide/","title":"SCREAM C++ Style Guide","text":"<p>Here's our style guide. Let the holy wars begin!</p>"},{"location":"dev/style_guide/#types","title":"Types","text":""},{"location":"dev/style_guide/#functions-and-methods","title":"Functions and Methods","text":""},{"location":"dev/style_guide/#variables","title":"Variables","text":""},{"location":"dev/testing/","title":"Testing","text":"<p>Here we describe our testing methodology:</p> <ul> <li>Unit tests</li> <li>Property (verification) tests</li> <li>Integration (validation?) tests</li> </ul> <p>It would be nice to have simple examples of all these.</p>"},{"location":"user/","title":"SCREAM User Guide","text":""}]}